<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chomp API Test Runner</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    h1 {
      color: #ff385c;
    }
    .test-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .test-controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .server-status {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .status-circle {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: #ccc;
    }
    .status-circle.connected {
      background-color: #4CAF50;
    }
    .status-circle.disconnected {
      background-color: #F44336;
    }
    button {
      background-color: #ff385c;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #e02e4c;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .test-list {
      margin-top: 20px;
    }
    .test-item {
      padding: 15px;
      border-left: 4px solid #ddd;
      margin-bottom: 10px;
      background-color: #f5f5f5;
    }
    .test-item.running {
      border-left-color: #2196F3;
      background-color: #e3f2fd;
    }
    .test-item.passed {
      border-left-color: #4CAF50;
      background-color: #e8f5e9;
    }
    .test-item.failed {
      border-left-color: #F44336;
      background-color: #ffebee;
    }
    .test-details {
      margin-top: 10px;
      padding: 10px;
      background-color: #fff;
      border-radius: 4px;
      border: 1px solid #eee;
      max-height: 200px;
      overflow-y: auto;
      position: relative;
    }
    
    .copy-button {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: #ff385c;
      color: white;
      border: 1px solid #e02e4c;
      border-radius: 3px;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.2s ease;
    }
    
    .copy-button:hover {
      background-color: #e02e4c;
      transform: translateY(-1px);
      box-shadow: 0 3px 5px rgba(0,0,0,0.15);
    }
    
    .copy-success {
      background-color: #4CAF50;
      color: white;
      border-color: #3d8b40;
    }
    .log-container {
      margin-top: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 4px;
      height: 300px;
      overflow-y: auto;
      font-family: monospace;
      border: 1px solid #ddd;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
    .log-entry.info {
      color: #2196F3;
    }
    .log-entry.success {
      color: #4CAF50;
    }
    .log-entry.error {
      color: #F44336;
    }
    .summary {
      margin-top: 20px;
      padding: 15px;
      background-color: #fff;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    pre {
      background-color: #f8f8f8;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    /* Tab Styles */
    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 2px solid #ff385c;
      padding-bottom: 5px;
    }
    .tab-button {
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      padding: 12px 24px;
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      margin-right: 5px;
      font-weight: bold;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    .tab-button:hover {
      background-color: #e0e0e0;
      border-bottom-color: #ff385c;
    }
    .tab-button.active {
      background-color: #ff385c;
      color: white;
      border-color: #ff385c;
      position: relative;
      top: 1px;
    }
    .tab-content {
      display: none;
      animation: fadeIn 0.5s;
    }
    .tab-content.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Schema Styles */
    .schema-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .schema-controls {
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
    }
    .schema-table {
      margin-bottom: 30px;
    }
    .schema-table h3 {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .schema-table table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    .schema-table th, .schema-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .schema-table th {
      background-color: #f5f5f5;
      font-weight: bold;
    }
    .schema-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .schema-table tr:hover {
      background-color: #f1f1f1;
    }
    .table-toggle {
      background-color: #f1f1f1;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
    }
    .search-box {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 250px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Chomp API Test Runner</h1>
    <p>Test all API endpoints with real data</p>
  </header>

  <div class="container">
    <div class="tabs">
      <button class="tab-button active" data-tab="test-tab">API Tests</button>
      <button class="tab-button" data-tab="schema-tab">Database Schema</button>
    </div>
    
    <div id="test-tab" class="tab-content active">
      <div class="test-container">
        <div class="test-controls">
          <div class="server-status">
            <div class="status-indicator">
              <div id="backend-status" class="status-circle disconnected"></div>
              <span>Backend Server</span>
            </div>
            <div class="status-indicator">
              <div id="frontend-status" class="status-circle disconnected"></div>
              <span>Frontend Server</span>
            </div>
          </div>
          <div>
            <button id="connect-btn">Connect to Servers</button>
            <button id="run-tests-btn" disabled>Run All Tests</button>
            <button id="clear-log-btn">Clear Log</button>
          </div>
        </div>

        <div class="test-list" id="test-list">
          <!-- Test items will be added here dynamically -->
        </div>
      </div>
      
      <div class="log-container" id="log-container">
        <h3>Test Log</h3>
        <div id="log"></div>
      </div>

      <div class="summary" id="summary">
        <h3>Test Summary</h3>
        <p>Connect to servers and run tests to see results.</p>
        <button id="copy-all-results" style="display: none;">Copy All Results</button>
      </div>
    </div>
    
    <div id="schema-tab" class="tab-content">
      <div class="schema-container">
        <div class="schema-controls">
          <div>
            <button id="load-schema-btn">Load Database Schema</button>
            <button id="refresh-schema-btn">Refresh Schema</button>
          </div>
          <div>
            <input type="text" id="schema-search" class="search-box" placeholder="Search tables and columns...">
          </div>
        </div>
        
        <div id="schema-loading" style="display: none;">
          <p>Loading database schema...</p>
        </div>
        
        <div id="schema-error" style="display: none;" class="test-item failed">
          <p>Error loading database schema. Please check server connection.</p>
          <div class="test-details" id="schema-error-details"></div>
        </div>
        
        <div id="schema-content">
          <!-- Schema content will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const PROXY_BASE_URL = '/api';
    const ACTUAL_API_BASE_URL = 'http://localhost:5001';
    const FRONTEND_URL = 'http://localhost:5173';
    
    // Global test data to share between tests
    window.testData = {
      auth: {
        token: null,
        user: null
      },
      userData: null,
      restaurant: null,
      dish: null,
      list: null
    };
    
    // Helper to handle fetch responses safely (read body once)
    async function handleApiResponse(response, context = '') {
      let data, raw = '', parseError = '';
      try {
        data = await response.json();
      } catch (err) {
        parseError = err.message;
        try {
          raw = await response.text();
        } catch (textErr) {
          raw = '[unreadable body]';
        }
        data = { parseError, raw };
      }
      if (!response.ok) {
        const errMsg = `${context} failed (status ${response.status}): ${raw || JSON.stringify(data)}`;
        console.error(errMsg);
        logMessage(errMsg, 'error');
        throw new Error(errMsg);
      }
      return data;
    }
    
    // API request function
    async function apiRequest(url, options = {}) {
      const fullUrl = url.startsWith('http') ? url : `${PROXY_BASE_URL}${url}`; // PROXY_BASE_URL is now '/api'
      try {
        const response = await fetch(fullUrl, options);
        return response;
      } catch (error) {
        console.error('API request failed:', error);
        throw error;
      }
    }
    
    // Test definitions
    const tests = [
      {
        id: 'health-check',
        name: 'Health Check',
        description: 'Check if the backend server is healthy',
        run: async () => {
          console.log('Running health check test...');
          try {
            const response = await apiRequest('/api/health');
            const data = await handleApiResponse(response, 'Health check');
            if (!data || (data.status !== 'UP' && data.proxyStatus !== 'UP' && data.success !== true)) {
              console.error('Health check response:', data);
              logMessage('Health check failed: ' + JSON.stringify(data), 'error');
              throw new Error('Health check failed');
            }
            return { message: 'Backend server is healthy', data };
          } catch (error) {
            console.error('Health check error:', error);
            throw error; // Do not use mock data, fail the test
          }
        }
      },
      {
        id: 'user-registration',
        name: 'User Registration',
        description: 'Register a new user',
        run: async () => {
          try {
            const uniqueSuffix = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;
const userData = {
  email: `test-${uniqueSuffix}@example.com`,
  password: 'Password123!',
  name: 'Test User'
};
            
            console.log('Registering user with data:', userData);
            
            const response = await apiRequest('/api/auth/register', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(userData)
            });
            const data = await handleApiResponse(response, 'Registration');
            console.log('Registration response:', data);
            if (!data.success || !data.token) {
  console.error('Registration failed:', data.message || 'Unknown error', { request: userData, response: data });
  logMessage(`Registration failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}\nRequest: ${JSON.stringify(userData)}`, 'error');
  throw new Error(`Registration failed: ${data.message || 'Unknown error'}`);
}
            window.testData.userData = userData;
            window.testData.auth = { token: data.token, user: data.user };
            console.log('Updated test data after registration:', window.testData);
            return { message: 'User registered successfully', data };
          } catch (error) {
            console.error('Registration error:', error);
            throw error; // Do not use mock data, fail the test
          }
        }
      },
      {
        id: 'user-login',
        name: 'User Login',
        description: 'Login with the registered user',
        run: async () => {
          // Get user data from previous test
          if (!window.testData.userData) {
            throw new Error('No user data available. Registration test may have failed.');
          }
          
          const { email, password } = window.testData.userData;
          console.log('Logging in with credentials:', { email, password });
          
          const response = await apiRequest('/api/auth/login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, password })
          });
          const data = await handleApiResponse(response, 'Login');
          console.log('Login response:', data);
          if (!data.success || !data.token) {
  console.error('Login failed:', data.message || 'Unknown error', { request: { email, password }, response: data });
  logMessage(`Login failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}\nRequest: ${JSON.stringify({ email, password })}`, 'error');
  throw new Error(`Login failed: ${data.message || 'Unknown error'}`);
}
          window.testData.auth = { token: data.token, user: data.user };
          console.log('Updated test data after login:', window.testData);
          return { message: 'User logged in successfully', data };
        }
      },
      {
        id: 'auth-status',
        name: 'Authentication Status',
        description: 'Check authentication status with token',
        run: async () => {
          // Get token from previous test
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          
          const token = window.testData.auth.token;
          console.log('Checking auth status with token:', token);
          
          const response = await apiRequest('/api/auth/status', {
            headers: {
              'Authorization': `Bearer ${token}`
            }
          });
          const data = await handleApiResponse(response, 'Auth status');
          console.log('Auth status response:', data);
          if (!data.success) {
            console.error('Auth status failed:', data.message || 'Unknown error');
            logMessage(`Auth status failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}`, 'error');
            throw new Error(`Auth status failed: ${data.message || 'Unknown error'}`);
          }
          return { message: 'Authentication status verified', data };
        }
      },
      {
        id: 'create-restaurant',
        name: 'Create Restaurant',
        description: 'Create a new restaurant',
        run: async () => {
          // Check if we have authentication token
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          
          const token = window.testData.auth.token;
          // Use E2E endpoint for restaurant creation
          const restaurantData = {
            name: `Test Restaurant ${Date.now()}`,
            address: '123 Test St',
            city: 'Test City',
            state: 'TS',
            zip: '12345',
            phone: '555-123-4567',
            cuisine: 'Test Cuisine',
            priceRange: '$$'
          };

          console.log('Creating restaurant with data:', restaurantData);

          const response = await apiRequest('/api/e2e/restaurants', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(restaurantData)
          });
          const data = await handleApiResponse(response, 'Create restaurant');
          console.log('Create restaurant response:', data);
          if (!data.success && !data.id) {
            console.error('Create restaurant failed:', data.message || 'Unknown error');
            logMessage(`Create restaurant failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}`, 'error');
            throw new Error(`Create restaurant failed: ${data.message || 'Unknown error'}`);
          }
          // Store restaurant data for subsequent tests
          window.testData.restaurant = data.restaurant || data;
          console.log('Stored restaurant data:', window.testData.restaurant);
          return { message: 'Restaurant created successfully', data };
        }
      },
      // E2E test: Create Dish for Restaurant
      {
        id: 'create-dish',
        name: 'Create Dish',
        description: 'Create a new dish for the restaurant',
        run: async () => {
          // Ensure restaurant data is present from previous test
          if (!window.testData.restaurant || !window.testData.restaurant.id) {
            throw new Error('No restaurant data available. Restaurant creation test may have failed.');
          }
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          // Use E2E endpoint for dish creation
          const token = window.testData.auth.token;
          const restaurantId = window.testData.restaurant.id;
          const dishData = {
            name: `Test Dish ${Date.now()}`,
            description: 'A test dish created by API tests',
            price: 9.99,
            restaurant_id: restaurantId,
            tags: ['test', 'api'],
            category: 'Main',
            dietary_restrictions: ['vegetarian']
          };
          console.log('Creating dish with data:', dishData);
          const response = await apiRequest('/api/e2e/dishes', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(dishData)
          });
          const data = await handleApiResponse(response, 'Create dish');
          console.log('Create dish response:', data);
          if (!data.success && !data.id) {
            console.error('Create dish failed:', data.message || 'Unknown error');
            logMessage(`Create dish failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}`, 'error');
            throw new Error(`Create dish failed: ${data.message || 'Unknown error'}`);
          }
          // Store dish data for subsequent tests
          window.testData.dish = data.dish || data;
          console.log('Stored dish data:', window.testData.dish);
          return { message: 'Dish created successfully', data };
        }
      },
      // E2E test: Get Dishes
      {
        id: 'get-dishes',
        name: 'Get Dishes',
        description: 'Get list of dishes',
        run: async () => {
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          // Use E2E endpoint for getting dishes
          const token = window.testData.auth.token;
          const response = await apiRequest('/api/e2e/dishes', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
const data = await handleApiResponse(response, 'Get dishes');
console.log('Get dishes response:', data);
if (!data.success) {
  console.error('Get dishes failed:', data.message || 'Unknown error');
  logMessage(`Get dishes failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}`, 'error');
  throw new Error(`Get dishes failed: ${data.message || 'Unknown error'}`);
}
return { message: `Retrieved ${data.data && data.data.dishes ? data.data.dishes.length : 0} dishes`, data };
        }
      },
      // E2E test: Get Restaurants
      {
        id: 'get-restaurants',
        name: 'Get Restaurants',
        description: 'Get list of restaurants',
        run: async () => {
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          // Use E2E endpoint for getting restaurants
          const token = window.testData.auth.token;
          const response = await apiRequest('/api/e2e/restaurants', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
const data = await handleApiResponse(response, 'Get restaurants');
console.log('Get restaurants response:', data);
if (!data.success) {
  console.error('Get restaurants failed:', data.message || 'Unknown error');
  logMessage(`Get restaurants failed: ${data.message || 'Unknown error'}\nDetails: ${JSON.stringify(data)}`, 'error');
  throw new Error(`Get restaurants failed: ${data.message || 'Unknown error'}`);
}
return { message: `Retrieved ${data.data && data.data.restaurants ? data.data.restaurants.length : 0} restaurants`, data };
        }
      }
    ];
    
    // DOM elements
    const connectBtn = document.getElementById('connect-btn');
    const runTestsBtn = document.getElementById('run-tests-btn');
    const clearLogBtn = document.getElementById('clear-log-btn');
    const testList = document.getElementById('test-list');
    const log = document.getElementById('log');
    const summary = document.getElementById('summary');
    const backendStatus = document.getElementById('backend-status');
    const frontendStatus = document.getElementById('frontend-status');
    const copyAllResultsBtn = document.getElementById('copy-all-results');
    const loadSchemaBtn = document.getElementById('load-schema-btn');
    const refreshSchemaBtn = document.getElementById('refresh-schema-btn');
    const schemaSearch = document.getElementById('schema-search');
    const schemaContent = document.getElementById('schema-content');
    const schemaLoading = document.getElementById('schema-loading');
    const schemaError = document.getElementById('schema-error');
    const schemaErrorDetails = document.getElementById('schema-error-details');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    
    // Initialize test list
    function initializeTestList() {
      testList.innerHTML = '';
      tests.forEach(test => {
        const testItem = document.createElement('div');
        testItem.className = 'test-item';
        testItem.id = `test-${test.id}`;
        testItem.innerHTML = `
          <h3>${test.name}</h3>
          <p>${test.description}</p>
          <div class="test-status">Status: <span id="status-${test.id}">Not Run</span></div>
          <div class="test-details" id="details-${test.id}" style="display: none;"></div>
        `;
        testList.appendChild(testItem);
      });
    }
    
    // Log functions
    function logMessage(message, type = 'info') {
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = message;
      log.appendChild(logEntry);
      log.scrollTop = log.scrollHeight;
    }
    
    function clearLog() {
      log.innerHTML = '';
      logMessage('Log cleared', 'info');
    }
    
    // Update test item
    function updateTestItem(id, status, details = null) {
      const testItem = document.getElementById(`test-${id}`);
      const statusSpan = document.getElementById(`status-${id}`);
      const detailsDiv = document.getElementById(`details-${id}`);
      
      if (!testItem || !statusSpan) return;
      
      // Remove previous status classes
      testItem.classList.remove('running', 'passed', 'failed');
      
      // Add new status class
      testItem.classList.add(status);
      
      // Update status text
      statusSpan.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      
      // Update details if provided
      if (details && detailsDiv) {
        detailsDiv.style.display = 'block';
        
        if (status === 'failed') {
          detailsDiv.innerHTML = `
            <p><strong>Error:</strong> ${details.message || 'Unknown error'}</p>
            ${details.stack ? `<pre>${details.stack}</pre>` : ''}
            <button class="copy-button" id="copy-${id}">Copy Error</button>
          `;
          
          // Add event listener to copy button
          setTimeout(() => {
            const copyBtn = document.getElementById(`copy-${id}`);
            if (copyBtn) {
              copyBtn.addEventListener('click', () => copyErrorDetails(id, details));
            }
          }, 0);
        } else {
          detailsDiv.innerHTML = `<p>${details.message || 'Test completed'}</p>`;
          if (details.data) {
            detailsDiv.innerHTML += `<pre>${JSON.stringify(details.data, null, 2)}</pre>`;
          }
        }
      }
    }
    
    // Copy error details to clipboard
    function copyErrorDetails(testId, details) {
      const copyBtn = document.getElementById(`copy-${testId}`);
      if (!copyBtn) return;
      
      const testName = tests.find(t => t.id === testId)?.name || 'Unknown Test';
      
      const errorText = `Test: ${testName}\n` +
        `Error: ${details.message || 'Unknown error'}\n` +
        `${details.stack ? `Stack Trace:\n${details.stack}` : ''}`;
      
      navigator.clipboard.writeText(errorText)
        .then(() => {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copy-success');
          
          setTimeout(() => {
            copyBtn.textContent = 'Copy Error';
            copyBtn.classList.remove('copy-success');
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy error details:', err);
          copyBtn.textContent = 'Copy Failed';
          
          setTimeout(() => {
            copyBtn.textContent = 'Copy Error';
          }, 2000);
        });
    }
    
    // Check server connections
    async function checkBackendConnection() {
      try {
        logMessage('Checking backend connection...', 'info');
        
        // Use the proxy server health endpoint
        const response = await fetch(`/health`);
        const data = await response.json();
        
        if (data && (data.proxyStatus === 'UP' || data.success === true)) {
          backendStatus.classList.remove('disconnected');
          backendStatus.classList.add('connected');
          logMessage('Backend server connected', 'success');
          return true;
        } else {
          throw new Error('Backend server is not healthy');
        }
      } catch (error) {
        console.error('Health check failed:', error);
        
        backendStatus.classList.remove('connected');
        backendStatus.classList.add('disconnected');
        logMessage(`Backend connection failed: ${error.message}`, 'error');
        console.error('Backend connection error:', error);
        return false;
      }
    }
    
    async function checkFrontendConnection() {
      try {
        logMessage('Checking frontend connection...', 'info');
        
        // For testing purposes, we'll mark the frontend as connected
        // since we don't actually need it for the API tests
        frontendStatus.classList.remove('disconnected');
        frontendStatus.classList.add('connected');
        logMessage('Frontend connection not required for API tests', 'success');
        return true;
        
        // The following code is commented out since we don't need the frontend
        // for API testing and it might not be running
        /*
        const response = await fetch(`${FRONTEND_URL}/ping`, { mode: 'no-cors' });
        
        // Since we're using no-cors, we can't actually read the response
        // But if we get here without an error, the server is probably up
        frontendStatus.classList.remove('disconnected');
        frontendStatus.classList.add('connected');
        logMessage('Frontend server connected', 'success');
        return true;
        */
      } catch (error) {
        // For testing purposes, we'll still mark the frontend as connected
        frontendStatus.classList.remove('disconnected');
        frontendStatus.classList.add('connected');
        logMessage('Frontend connection not required for API tests', 'success');
        console.log('Frontend connection skipped for API testing');
        return true;
      }
    }
    
    // Connect to servers
    async function connectToServers() {
      logMessage('Connecting to servers...', 'info');
      const backendConnected = await checkBackendConnection();
      
      // Always check frontend connection, but we don't actually need it for API tests
      const frontendConnected = await checkFrontendConnection();
      
      if (backendConnected) {
        runTestsBtn.disabled = false;
        logMessage('Ready to run tests', 'success');
      } else {
        // Try one more time with a direct connection to the backend
        try {
          logMessage('Trying direct connection to backend...', 'info');
          const response = await fetch(`http://localhost:5001/api/health`);
          const data = await response.json();
          
          if (data && data.status === 'UP') {
            backendStatus.classList.remove('disconnected');
            backendStatus.classList.add('connected');
            logMessage('Backend server connected directly', 'success');
            runTestsBtn.disabled = false;
            return;
          }
        } catch (error) {
          console.error('Direct backend connection failed:', error);
        }
        
        runTestsBtn.disabled = true;
        logMessage('Cannot run tests without backend connection', 'error');
      }
    }
    
    // Run a single test with timeout
    async function runTest(test) {
      const testId = test.id;
      updateTestItem(testId, 'running');
      logMessage(`Running test: ${test.name}`, 'info');
      
      try {
        // Set a timeout for the test (30 seconds)
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`Test timed out after 30 seconds`)), 30000);
        });
        
        // Run the test
        const result = await Promise.race([test.run(), timeoutPromise]);
        
        updateTestItem(testId, 'passed', result);
        logMessage(`Test passed: ${test.name}`, 'success');
        return { success: true, testId, result };
      } catch (error) {
        console.error(`[TEST FAILED] ${test.name}`, error);
        console.error('Error object:', error);
        console.error('Stack trace:', error.stack);
        
        updateTestItem(testId, 'failed', {
          message: error.message,
          stack: error.stack
        });
        
        logMessage(`Test failed: ${test.name} - ${error.message}`, 'error');
        return { success: false, testId, error };
      }
    }
    
    // Reset connections
    function resetConnections() {
      backendStatus.classList.remove('connected');
      backendStatus.classList.add('disconnected');
      frontendStatus.classList.remove('connected');
      frontendStatus.classList.add('disconnected');
      
      runTestsBtn.disabled = true;
      
      // Reset test items
      tests.forEach(test => {
        const testItem = document.getElementById(`test-${test.id}`);
        if (testItem) {
          testItem.classList.remove('running', 'passed', 'failed');
        }
        
        const statusSpan = document.getElementById(`status-${test.id}`);
        if (statusSpan) {
          statusSpan.textContent = 'Not Run';
        }
        
        const detailsDiv = document.getElementById(`details-${test.id}`);
        if (detailsDiv) {
          detailsDiv.style.display = 'none';
          detailsDiv.innerHTML = '';
        }
      });
      
      // Reset summary
      summary.innerHTML = '<h3>Test Summary</h3><p>Connect to servers and run tests to see results.</p>';
      copyAllResultsBtn.style.display = 'none';
    }
    
    // Run all tests
    async function runAllTests() {
      // Reset test data
      window.testData = {
        auth: {
          token: null,
          user: null
        },
        userData: null,
        restaurant: null,
        dish: null,
        list: null
      };
      
      logMessage('Running all tests...', 'info');
      
      let results = [];
      
      // Run tests sequentially
      for (const test of tests) {
        const result = await runTest(test);
        results.push(result);
        
        // If a test fails, we might want to stop subsequent tests
        // that depend on it, but for now we'll continue with all tests
      }
      
      updateSummary(results);
    }
    
    // Update test summary
    function updateSummary(results) {
      const passed = results.filter(r => r.success).length;
      const failed = results.filter(r => !r.success).length;
      const total = results.length;
      
      summary.innerHTML = `
        <h3>Test Summary</h3>
        <p>Total: ${total} | Passed: ${passed} | Failed: ${failed}</p>
      `;
      
      copyAllResultsBtn.style.display = 'inline-block';
    }
    
    // Copy all test results to clipboard
    function copyAllTestResults() {
      const results = [];
      
      tests.forEach(test => {
        const testItem = document.getElementById(`test-${test.id}`);
        const statusSpan = document.getElementById(`status-${test.id}`);
        const detailsDiv = document.getElementById(`details-${test.id}`);
        
        if (testItem && statusSpan) {
          const status = statusSpan.textContent;
          let details = '';
          
          if (detailsDiv && detailsDiv.style.display !== 'none') {
            details = detailsDiv.textContent.trim();
          }
          
          results.push(`Test: ${test.name}\nStatus: ${status}\n${details ? `Details:\n${details}\n` : ''}`);
        }
      });
      
      const resultsText = results.join('\n---\n\n');
      
      navigator.clipboard.writeText(resultsText)
        .then(() => {
          copyAllResultsBtn.textContent = 'Results Copied!';
          
          setTimeout(() => {
            copyAllResultsBtn.textContent = 'Copy All Results';
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy results:', err);
          copyAllResultsBtn.textContent = 'Copy Failed';
          
          setTimeout(() => {
            copyAllResultsBtn.textContent = 'Copy All Results';
          }, 2000);
        });
    }
    
    // Database Schema Functions
    let schemaData = null;
    
    async function loadDatabaseSchema() {
      schemaLoading.style.display = 'block';
      schemaContent.innerHTML = '';
      schemaError.style.display = 'none';
      
      try {
        logMessage('Loading database schema...', 'info');
        const response = await fetch(`${PROXY_BASE_URL}/api/db-schema`);
        
        if (!response.ok) {
          throw new Error(`Failed to load schema: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        schemaData = data;
        
        renderSchemaData(data);
        logMessage('Database schema loaded successfully', 'success');
      } catch (error) {
        console.error('Schema loading error:', error);
        schemaError.style.display = 'block';
        schemaErrorDetails.textContent = error.message;
        logMessage(`Failed to load database schema: ${error.message}`, 'error');
      } finally {
        schemaLoading.style.display = 'none';
      }
    }
    
    function renderSchemaData(data) {
      if (!data || !data.tables || data.tables.length === 0) {
        schemaContent.innerHTML = '<p>No schema data available</p>';
        return;
      }
      
      schemaContent.innerHTML = '';
      
      data.tables.forEach(table => {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'schema-table';
        tableDiv.dataset.tableName = table.name.toLowerCase();
        
        const tableHeader = document.createElement('h3');
        tableHeader.innerHTML = `
          <span>${table.name}</span>
          <button class="table-toggle" data-table="${table.name}">Toggle</button>
        `;
        
        const tableContent = document.createElement('div');
        tableContent.id = `table-content-${table.name}`;
        
        if (table.columns && table.columns.length > 0) {
          const table = document.createElement('table');
          table.innerHTML = `
            <thead>
              <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Nullable</th>
                <th>Default</th>
                <th>Extra</th>
              </tr>
            </thead>
            <tbody>
              ${table.columns.map(col => `
                <tr data-column-name="${col.name.toLowerCase()}">
                  <td>${col.name}</td>
                  <td>${col.type}</td>
                  <td>${col.nullable ? 'YES' : 'NO'}</td>
                  <td>${col.default || ''}</td>
                  <td>${col.extra || ''}</td>
                </tr>
              `).join('')}
            </tbody>
          `;
          
          tableContent.appendChild(table);
        } else {
          tableContent.innerHTML = '<p>No columns available for this table</p>';
        }
        
        tableDiv.appendChild(tableHeader);
        tableDiv.appendChild(tableContent);
        schemaContent.appendChild(tableDiv);
        
        // Add toggle functionality
        const toggleBtn = tableHeader.querySelector('.table-toggle');
        toggleBtn.addEventListener('click', () => {
          const content = document.getElementById(`table-content-${table.name}`);
          content.style.display = content.style.display === 'none' ? 'block' : 'none';
        });
      });
      
      // Add event listeners to toggle buttons
      document.querySelectorAll('.table-toggle').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tableName = e.target.dataset.table;
          const content = document.getElementById(`table-content-${tableName}`);
          if (content) {
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
          }
        });
      });
    }
    
    function filterSchema(searchTerm) {
      if (!schemaData || !schemaData.tables) return;
      
      const term = searchTerm.toLowerCase();
      
      document.querySelectorAll('.schema-table').forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName;
        let tableMatches = tableName.includes(term);
        let anyColumnMatches = false;
        
        // Check if any column in this table matches
        tableDiv.querySelectorAll('tr[data-column-name]').forEach(row => {
          const columnName = row.dataset.columnName;
          const columnMatches = columnName.includes(term);
          
          if (columnMatches) {
            anyColumnMatches = true;
            row.style.display = 'table-row';
            row.style.backgroundColor = '#fffde7'; // Highlight matching columns
          } else {
            row.style.display = term ? 'none' : 'table-row';
            row.style.backgroundColor = '';
          }
        });
        
        // Show/hide the table based on matches
        if (tableMatches || anyColumnMatches || !term) {
          tableDiv.style.display = 'block';
          if (tableMatches) {
            tableDiv.style.backgroundColor = '#fffde7'; // Highlight matching tables
          } else {
            tableDiv.style.backgroundColor = '';
          }
        } else {
          tableDiv.style.display = 'none';
        }
      });
    }
    
    // Tab switching functionality
    function switchTab(tabId) {
      // Hide all tab contents
      tabContents.forEach(content => {
        content.classList.remove('active');
      });
      
      // Deactivate all tab buttons
      tabButtons.forEach(button => {
        button.classList.remove('active');
      });
      
      // Activate the selected tab
      document.getElementById(tabId).classList.add('active');
      
      // Activate the corresponding button
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      
      // Load schema data if switching to schema tab
      if (tabId === 'schema-tab' && !schemaData) {
        loadDatabaseSchema();
      }
    }
    
    // Event listeners
    connectBtn.addEventListener('click', connectToServers);
    runTestsBtn.addEventListener('click', runAllTests);
    clearLogBtn.addEventListener('click', clearLog);
    copyAllResultsBtn.addEventListener('click', copyAllTestResults);
    loadSchemaBtn.addEventListener('click', loadDatabaseSchema);
    refreshSchemaBtn.addEventListener('click', loadDatabaseSchema);
    
    // Schema search
    schemaSearch.addEventListener('input', (e) => {
      filterSchema(e.target.value);
    });
    
    // Tab switching
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const tabId = button.dataset.tab;
        switchTab(tabId);
      });
    });
    
    // Initialize the test list
    initializeTestList();
    
    // Auto-connect to servers when page loads
    window.addEventListener('load', () => {
      setTimeout(connectToServers, 500);
    });
  </script>
</body>
</html>
