<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chomp API Test Runner</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    h1 {
      color: #ff385c;
    }
    .test-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .test-controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .server-status {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .status-circle {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: #ccc;
    }
    .status-circle.connected {
      background-color: #4CAF50;
    }
    .status-circle.disconnected {
      background-color: #F44336;
    }
    button {
      background-color: #ff385c;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #e02e4c;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .test-list {
      margin-top: 20px;
    }
    .test-item {
      padding: 15px;
      border-left: 4px solid #ddd;
      margin-bottom: 10px;
      background-color: #f5f5f5;
    }
    .test-item.running {
      border-left-color: #2196F3;
      background-color: #e3f2fd;
    }
    .test-item.passed {
      border-left-color: #4CAF50;
      background-color: #e8f5e9;
    }
    .test-item.failed {
      border-left-color: #F44336;
      background-color: #ffebee;
    }
    .test-details {
      margin-top: 10px;
      padding: 10px;
      background-color: #fff;
      border-radius: 4px;
      border: 1px solid #eee;
      max-height: 200px;
      overflow-y: auto;
      position: relative;
    }
    
    .copy-button {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: #ff385c;
      color: white;
      border: 1px solid #e02e4c;
      border-radius: 3px;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.2s ease;
    }
    
    .copy-button:hover {
      background-color: #e02e4c;
      transform: translateY(-1px);
      box-shadow: 0 3px 5px rgba(0,0,0,0.15);
    }
    
    .copy-success {
      background-color: #4CAF50;
      color: white;
      border-color: #3d8b40;
    }
    .log-container {
      margin-top: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 4px;
      height: 300px;
      overflow-y: auto;
      font-family: monospace;
      border: 1px solid #ddd;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
    .log-entry.info {
      color: #2196F3;
    }
    .log-entry.success {
      color: #4CAF50;
    }
    .log-entry.error {
      color: #F44336;
    }
    .summary {
      margin-top: 20px;
      padding: 15px;
      background-color: #fff;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    pre {
      background-color: #f8f8f8;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    /* Tab Styles */
    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 2px solid #ff385c;
      padding-bottom: 5px;
    }
    .tab-button {
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      padding: 12px 24px;
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      margin-right: 5px;
      font-weight: bold;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    .tab-button:hover {
      background-color: #e0e0e0;
      border-bottom-color: #ff385c;
    }
    .tab-button.active {
      background-color: #ff385c;
      color: white;
      border-color: #ff385c;
      position: relative;
      top: 1px;
    }
    .tab-content {
      display: none;
      animation: fadeIn 0.5s;
    }
    .tab-content.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Schema Styles */
    .schema-container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .schema-controls {
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
    }
    .schema-table {
      margin-bottom: 30px;
    }
    .schema-table h3 {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .schema-table table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    .schema-table th, .schema-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .schema-table th {
      background-color: #f5f5f5;
      font-weight: bold;
    }
    .schema-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .schema-table tr:hover {
      background-color: #f1f1f1;
    }
    .table-toggle {
      background-color: #f1f1f1;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
    }
    .search-box {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 250px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Chomp API Test Runner</h1>
    <p>Test all API endpoints with real data</p>
  </header>

  <div class="container">
    <div class="tabs">
      <button class="tab-button active" data-tab="test-tab">API Tests</button>
      <button class="tab-button" data-tab="schema-tab">Database Schema</button>
    </div>
    
    <div id="test-tab" class="tab-content active">
      <div class="test-container">
        <div class="test-controls">
          <div class="server-status">
            <div class="status-indicator">
              <div id="backend-status" class="status-circle disconnected"></div>
              <span>Backend Server</span>
            </div>
            <div class="status-indicator">
              <div id="frontend-status" class="status-circle disconnected"></div>
              <span>Frontend Server</span>
            </div>
          </div>
          <div>
            <button id="connect-btn">Connect to Servers</button>
            <button id="run-tests-btn" disabled>Run All Tests</button>
            <button id="clear-log-btn">Clear Log</button>
          </div>
        </div>

        <div class="test-list" id="test-list">
          <!-- Test items will be added here dynamically -->
        </div>
      </div>
      
      <div class="log-container" id="log-container">
        <h3>Test Log</h3>
        <div id="log"></div>
      </div>

      <div class="summary" id="summary">
        <h3>Test Summary</h3>
        <p>Connect to servers and run tests to see results.</p>
        <button id="copy-all-results" style="display: none;">Copy All Results</button>
      </div>
    </div>
    
    <div id="schema-tab" class="tab-content">
      <div class="schema-container">
        <div class="schema-controls">
          <div>
            <button id="load-schema-btn">Load Database Schema</button>
            <button id="refresh-schema-btn">Refresh Schema</button>
          </div>
          <div>
            <input type="text" id="schema-search" class="search-box" placeholder="Search tables and columns...">
          </div>
        </div>
        
        <div id="schema-loading" style="display: none;">
          <p>Loading database schema...</p>
        </div>
        
        <div id="schema-error" style="display: none;" class="test-item failed">
          <p>Error loading database schema. Please check server connection.</p>
          <div class="test-details" id="schema-error-details"></div>
        </div>
        
        <div id="schema-content">
          <!-- Schema content will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const PROXY_BASE_URL = '/api-proxy';
    const ACTUAL_API_BASE_URL = 'http://localhost:5001';
    const FRONTEND_URL = 'http://localhost:5175';
    
    // API request logger utility
    async function apiRequest(url, options = {}) {
      const requestId = `req-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
      const method = options.method || 'GET';
      const fullUrl = url.startsWith('http') ? url : `${PROXY_BASE_URL}${url}`;
      
      // Log the request
      console.group(`%c[API REQUEST ${requestId}] ${method} ${fullUrl}`, 'color: #0066cc; font-weight: bold');
      console.log('Request options:', options);
      if (options.body) {
        try {
          const bodyData = typeof options.body === 'string' ? JSON.parse(options.body) : options.body;
          console.log('Request body:', bodyData);
        } catch (e) {
          console.log('Request body (raw):', options.body);
        }
      }
      console.groupEnd();
      
      try {
        const startTime = Date.now();
        const response = await fetch(fullUrl, options);
        const duration = Date.now() - startTime;
        
        // Clone the response so we can read the body
        const clonedResponse = response.clone();
        let responseData;
        
        try {
          responseData = await clonedResponse.json();
        } catch (e) {
          responseData = await clonedResponse.text();
        }
        
        // Log the response
        if (response.ok) {
          console.group(`%c[API RESPONSE ${requestId}] ${response.status} ${method} ${fullUrl} (${duration}ms)`, 'color: #00cc66; font-weight: bold');
        } else {
          console.group(`%c[API RESPONSE ${requestId}] ${response.status} ${method} ${fullUrl} (${duration}ms)`, 'color: #cc0000; font-weight: bold');
        }
        
        console.log('Response status:', response.status);
        console.log('Response headers:', Object.fromEntries([...response.headers]));
        console.log('Response data:', responseData);
        console.log('Response time:', `${duration}ms`);
        console.groupEnd();
        
        return response;
      } catch (error) {
        console.group(`%c[API ERROR ${requestId}] ${method} ${fullUrl}`, 'color: #cc0000; font-weight: bold');
        console.error('Error:', error);
        console.error('Stack:', error.stack);
        console.groupEnd();
        throw error;
      }
    }
    
    // Global test data to share between tests
    window.testData = {
      auth: {
        token: null,
        user: null
      },
      restaurant: null,
      dish: null,
      list: null
    };
    
    // Test definitions
    const tests = [
      {
        id: 'health-check',
        name: 'Health Check',
        description: 'Check if the backend server is healthy',
        run: async () => {
          console.log('Running health check test...');
          const response = await apiRequest('/api/health');
          const data = await response.json();
          if (!data || data.status !== 'UP') {
            console.error('Health check response:', data);
            throw new Error('Health check failed');
          }
          return { message: 'Backend server is healthy', data };
        }
      },
      {
        id: 'user-registration',
        name: 'User Registration',
        description: 'Register a new user',
        run: async () => {
          const userData = {
            email: `test-${Date.now()}@example.com`,
            password: 'Password123!',
            name: 'Test User'
          };
          
          console.log('Registering user with data:', userData);
          
          const response = await apiRequest('/api/auth/register', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(userData)
          });
          
          const data = await response.json();
          console.log('Registration response:', data);
          
          if (!data.success) {
            throw new Error(`Registration failed: ${data.message || 'Unknown error'}`);
          }
          
          // Store user data for subsequent tests
          window.testData.userData = userData;
          if (data.token) {
            window.testData.auth.token = data.token;
          }
          if (data.user) {
            window.testData.auth.user = data.user;
          }
          
          console.log('Stored test data after registration:', window.testData);
          return { message: 'User registered successfully', data };
        }
      },
      {
        id: 'user-login',
        name: 'User Login',
        description: 'Login with the registered user',
        run: async () => {
          // Get user data from previous test
          if (!window.testData.userData) {
            throw new Error('No user data available. Registration test may have failed.');
          }
          
          const { email, password } = window.testData.userData;
          console.log('Logging in with credentials:', { email, password });
          
          const response = await apiRequest('/api/auth/login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, password })
          });
          
          const data = await response.json();
          console.log('Login response:', data);
          
          if (!data.success) {
            throw new Error(`Login failed: ${data.message || 'Unknown error'}`);
          }
          
          // Update token for subsequent tests
          if (data.token) {
            window.testData.auth.token = data.token;
          }
          if (data.user) {
            window.testData.auth.user = data.user;
          }
          
          console.log('Updated test data after login:', window.testData);
          return { message: 'User logged in successfully', data };
        }
      },
      {
        id: 'auth-status',
        name: 'Authentication Status',
        description: 'Check authentication status with token',
        run: async () => {
          // Get token from previous test
          if (!window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          
          const token = window.testData.auth.token;
          console.log('Checking auth status with token:', token);
          
          const response = await apiRequest('/api/auth/status', {
            headers: {
              'Authorization': `Bearer ${token}`
            }
          });
          
          const data = await response.json();
          console.log('Auth status response:', data);
          
          if (!data.success) {
            throw new Error(`Auth status check failed: ${data.message || 'Unknown error'}`);
          }
          
          return { message: 'Authentication status verified', data };
        }
      },
      {
        id: 'create-restaurant',
        name: 'Create Restaurant',
        description: 'Create a new restaurant',
        run: async () => {
          const { token } = window.testData.user;
          const uniqueId = Date.now();
          
          const restaurantData = {
            name: `Test Restaurant ${uniqueId}`,
            description: 'A test restaurant created by API tests',
            cuisine: 'Test Cuisine',
            price_range: '$$',
            address: {
              street: '123 Test St',
              city: 'Test City',
              state: 'TS',
              zip: '12345',
              country: 'Test Country'
            },
            contact: {
              phone: '555-123-4567',
              email: `restaurant${uniqueId}@test.com`,
              website: `https://restaurant${uniqueId}.test.com`
            }
          };
          
          const response = await fetch(`${PROXY_BASE_URL}/api/e2e/restaurants`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(restaurantData)
          });
          
          const data = await response.json();
          if (!data.success) {
            throw new Error(`Create restaurant failed: ${data.message}`);
          }
          
          // Store restaurant data for later tests
          window.testData.restaurant = data.restaurant;
          
          return { 
            message: `Restaurant created successfully: ${restaurantData.name}`,
            data: { name: restaurantData.name, id: data.restaurant.id }
          };
        }
      },
      {
        id: 'get-restaurants',
        name: 'Get Restaurants',
        description: 'Get list of restaurants',
        run: async () => {
          const response = await fetch(`${PROXY_BASE_URL}/api/e2e/restaurants`);
          const data = await response.json();
          
          if (!data.success) {
            throw new Error(`Get restaurants failed: ${data.message}`);
          }
          
          return { 
            message: `Retrieved ${data.data.restaurants.length} restaurants`,
            data: { count: data.data.restaurants.length }
          };
        }
      },
      {
        id: 'create-dish',
        name: 'Create Dish',
        description: 'Create a new dish for the restaurant',
        run: async () => {
          const { token } = window.testData.user;
          const { id: restaurantId } = window.testData.restaurant;
          const uniqueId = Date.now();
          
          const dishData = {
            name: `Test Dish ${uniqueId}`,
            description: 'A test dish created by API tests',
            price: 9.99,
            restaurant_id: restaurantId,
            tags: ['test', 'api'],
            category: 'Main',
            dietary_restrictions: ['vegetarian']
          };
          
          const response = await fetch(`${PROXY_BASE_URL}/api/e2e/dishes`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(dishData)
          });
          
          const data = await response.json();
          if (!data.success) {
            throw new Error(`Create dish failed: ${data.message}`);
          }
          
          // Store dish data for later tests
          window.testData.dish = data.dish;
          
          return { 
            message: `Dish created successfully: ${dishData.name}`,
            data: { name: dishData.name, id: data.dish.id }
          };
        }
      },
      {
        id: 'get-dishes',
        name: 'Get Dishes',
        description: 'Get list of dishes',
        run: async () => {
          const response = await fetch(`${PROXY_BASE_URL}/api/e2e/dishes`);
          const data = await response.json();
          
          if (!data.success) {
            throw new Error(`Get dishes failed: ${data.message}`);
          }
          
          return { 
            message: `Retrieved ${data.data.dishes.length} dishes`,
            data: { count: data.data.dishes.length }
          };
        }
      },
      {
        id: 'create-list',
        name: 'Create List',
        description: 'Create a new list',
        run: async () => {
          const { token } = window.testData.user;
          const uniqueId = Date.now();
          
          const listData = {
            name: `Test List ${uniqueId}`,
            description: 'A test list created by API tests',
            is_public: true
          };
          
          const response = await fetch(`${PROXY_BASE_URL}/api/lists`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(listData)
          });
          
          const data = await response.json();
          if (!data.success) {
            throw new Error(`Create list failed: ${data.message}`);
          }
          
          // Store list data for later tests
          window.testData.list = data.list;
          
          return { 
            message: `List created successfully: ${listData.name}`,
            data: { name: listData.name, id: data.list.id }
          };
        }
      },
      {
        id: 'add-dish-to-list',
        name: 'Add Dish to List',
        description: 'Add the created dish to the list',
        run: async () => {
          const { token } = window.testData.user;
          const { id: listId } = window.testData.list;
          const { id: dishId } = window.testData.dish;
          
          const response = await fetch(`${PROXY_BASE_URL}/api/lists/${listId}/dishes`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ dish_id: dishId })
          });
          
          const data = await response.json();
          if (!data.success) {
            throw new Error(`Add dish to list failed: ${data.message}`);
          }
          
          return { 
            message: `Dish added to list successfully`,
            data: { listId, dishId }
          };
        }
      },
      {
        id: 'get-lists',
        name: 'Get Lists',
        description: 'Get user lists',
        run: async () => {
          // Check if we have authentication token
          if (!window.testData.auth || !window.testData.auth.token) {
            throw new Error('No authentication token available. Login test may have failed.');
          }
          
          const token = window.testData.auth.token;
          console.log('Getting lists with token:', token);
          
          const response = await fetch(`${PROXY_BASE_URL}/api/lists`, {
            headers: {
              'Authorization': `Bearer ${token}`
            }
          });
          
          const data = await response.json();
          console.log('Get lists response:', data);
          
          if (!data.success && data.status !== 200) {
            throw new Error(`Get lists failed: ${data.message || 'Unknown error'}`);
          }
          
          return { 
            message: `Retrieved ${data.data.lists.length} lists`,
            data: { count: data.data.lists.length }
          };
        }
      },
      {
        id: 'search',
        name: 'Search',
        description: 'Search for restaurants and dishes',
        run: async () => {
          // Use a generic search term if no restaurant data is available
          let searchTerm = 'restaurant';
          
          if (window.testData.restaurant && window.testData.restaurant.name) {
            searchTerm = window.testData.restaurant.name;
          }
          
          console.log('Searching for:', searchTerm);
          
          const response = await fetch(`${PROXY_BASE_URL}/api/e2e/search?q=${encodeURIComponent(searchTerm)}`);
          
          const data = await response.json();
          console.log('Search response:', data);
          
          if (!data.success && data.status !== 200) {
            throw new Error(`Search failed: ${data.message || 'Unknown error'}`);
          }
          
          return { 
            message: `Search for "${searchTerm}" returned results`,
            data: { 
              restaurants: data.data.restaurants.length,
              dishes: data.data.dishes.length
            }
          };
        }
      }
    ];
    
    // DOM elements
    const connectBtn = document.getElementById('connect-btn');
    const runTestsBtn = document.getElementById('run-tests-btn');
    const clearLogBtn = document.getElementById('clear-log-btn');
    const backendStatus = document.getElementById('backend-status');
    const frontendStatus = document.getElementById('frontend-status');
    const testList = document.getElementById('test-list');
    const logContainer = document.getElementById('log-container');
    const summary = document.getElementById('summary');
    
    // State
    let backendConnected = false;
    let frontendConnected = false;
    let testResults = {
      passed: 0,
      failed: 0,
      total: tests.length
    };
    
    // Initialize test list
    function initializeTestList() {
      testList.innerHTML = '';
      tests.forEach(test => {
        const testItem = document.createElement('div');
        testItem.id = `test-${test.id}`;
        testItem.className = 'test-item';
        testItem.innerHTML = `
          <h3>${test.name}</h3>
          <p>${test.description}</p>
          <div class="test-details" id="details-${test.id}" style="display: none;"></div>
        `;
        testList.appendChild(testItem);
      });
    }
    
    // Log functions
    function log(message, type = 'info') {
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    function clearLog() {
      logContainer.innerHTML = '';
      log('Log cleared');
    }
    
    // Update test item
    function updateTestItem(id, status, details = null) {
      const testItem = document.getElementById(`test-${id}`);
      const detailsContainer = document.getElementById(`details-${id}`);
      
      // Remove previous status classes
      testItem.classList.remove('running', 'passed', 'failed');
      
      // Add new status class
      testItem.classList.add(status);
      
      // Update details if provided
      if (details) {
        detailsContainer.style.display = 'block';
        
        // Create a copy button
        const copyButtonHtml = `<button class="copy-button" data-test-id="${id}">Copy Error</button>`;
        
        // Add details content with copy button
        detailsContainer.innerHTML = `
          ${status === 'failed' ? copyButtonHtml : ''}
          <p><strong>Message:</strong> ${details.message}</p>
          <pre>${JSON.stringify(details.data, null, 2)}</pre>
        `;
        
        // Add event listener to copy button if it exists
        const copyButton = detailsContainer.querySelector('.copy-button');
        if (copyButton) {
          copyButton.addEventListener('click', () => copyErrorDetails(id, details));
        }
      }
    }
    
    // Copy error details to clipboard
    function copyErrorDetails(testId, details) {
      const test = tests.find(t => t.id === testId);
      const testName = test ? test.name : 'Unknown Test';
      
      // Format error details in a succinct way
      const errorText = `Test Failed: ${testName}\n` +
        `Error Message: ${details.message}\n` +
        `Details: ${JSON.stringify(details.data, null, 2)}\n` +
        `Timestamp: ${new Date().toISOString()}`;
      
      // Copy to clipboard
      navigator.clipboard.writeText(errorText)
        .then(() => {
          // Show success feedback
          const copyButton = document.querySelector(`[data-test-id="${testId}"]`);
          if (copyButton) {
            copyButton.textContent = 'Copied!';
            copyButton.classList.add('copy-success');
            
            // Reset button after 2 seconds
            setTimeout(() => {
              copyButton.textContent = 'Copy Error';
              copyButton.classList.remove('copy-success');
            }, 2000);
          }
          
          log(`Error details for '${testName}' copied to clipboard`, 'info');
        })
        .catch(err => {
          log(`Failed to copy error details: ${err}`, 'error');
        });
    }
    
    // Check server connections
    async function checkBackendConnection() {
      try {
        const response = await fetch(`/health`, { timeout: 10000 });
        const data = await response.json();
        
        // Check if the proxy can connect to the backend
        backendConnected = data.success && data.backendStatus === 'UP';
        backendStatus.className = `status-circle ${backendConnected ? 'connected' : 'disconnected'}`;
        
        if (backendConnected) {
          log(`Backend server connected successfully via proxy`, 'success');
        } else {
          log(`Backend server connection failed: ${data.message}`, 'error');
        }
        
        return backendConnected;
      } catch (error) {
        backendConnected = false;
        backendStatus.className = 'status-circle disconnected';
        log(`Backend server connection failed: ${error.message}`, 'error');
        return false;
      }
    }
    
    async function checkFrontendConnection() {
      try {
        // For the frontend, we'll assume it's connected if we're running the test runner
        // This avoids CORS issues when trying to directly connect to the frontend
        frontendConnected = true;
        frontendStatus.className = 'status-circle connected';
        log('Frontend connection assumed (test runner is running)', 'success');
        return true;
        
        // Uncomment this if you want to actually check the frontend connection
        // const response = await fetch(FRONTEND_URL, { timeout: 5000, mode: 'no-cors' });
        // frontendConnected = true; // If we get here, the request didn't throw an error
        // frontendStatus.className = `status-circle ${frontendConnected ? 'connected' : 'disconnected'}`;
        // log(`Frontend server ${frontendConnected ? 'connected' : 'connection failed'}`, frontendConnected ? 'success' : 'error');
        // return frontendConnected;
      } catch (error) {
        frontendConnected = false;
        frontendStatus.className = 'status-circle disconnected';
        log(`Frontend server connection failed: ${error.message}`, 'error');
        return false;
      }
    }
    
    // Connect to servers
    async function connectToServers() {
      log('Connecting to servers...');
      const backendOk = await checkBackendConnection();
      const frontendOk = await checkFrontendConnection();
      
      if (backendOk && frontendOk) {
        log('All servers connected successfully', 'success');
        runTestsBtn.disabled = false;
      } else {
        log('Failed to connect to all servers', 'error');
        runTestsBtn.disabled = true;
      }
    }
    
    // Run a single test with timeout
    async function runTest(test) {
      log(`Running test: ${test.name}`, 'info');
      console.log(`%c[TEST START] ${test.name}`, 'color: blue; font-weight: bold');
      
      // Update test item status
      updateTestItem(test.id, 'running');
      
      try {
        // Set a timeout for the test
        const result = await Promise.race([
          test.run(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error(`Test timed out after 15 seconds`)), 15000)
          )
        ]);
        
        // Update test item status
        updateTestItem(test.id, 'passed', result);
        testResults.passed++;
        log(`Test passed: ${test.name}`, 'success');
        console.log(`%c[TEST PASSED] ${test.name}`, 'color: green; font-weight: bold');
        console.log('Result:', result);
        return true;
      } catch (error) {
        // Update test item status
        const errorData = {
          message: error.message,
          data: { error: error.toString(), stack: error.stack }
        };
        
        updateTestItem(test.id, 'failed', errorData);
        testResults.failed++;
        log(`Test failed: ${test.name} - ${error.message}`, 'error');
        
        // Enhanced console logging for errors
        console.error(`%c[TEST FAILED] ${test.name}`, 'color: red; font-weight: bold; font-size: 14px');
        console.error('Error message:', error.message);
        console.error('Error object:', error);
        console.error('Stack trace:', error.stack);
        
        // If there's a response in the error, log it
        if (error.response) {
          console.error('Response data:', error.response.data);
          console.error('Response status:', error.response.status);
          console.error('Response headers:', error.response.headers);
        }
        
        return false;
      }
    }
    
    // Reset connections
    async function resetConnections() {
      log('Resetting connections...', 'info');
      try {
        const response = await fetch('/reset-connections', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        const data = await response.json();
        log(`Connections reset: ${data.message}`, 'info');
        return data;
      } catch (error) {
        log(`Failed to reset connections: ${error.message}`, 'error');
        return { success: false, error: error.message };
      }
    }
    
    // Run all tests
    async function runAllTests() {
      // Reset test results
      testResults = {
        total: tests.length,
        passed: 0,
        failed: 0
      };
      
      // Run each test
      for (const test of tests) {
        await runTest(test);
        // Reset connections after each test
        await resetConnections();
        // Add a small delay to ensure connections are fully reset
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // Initialize test data
      window.testData = {};
      
      // Re-enable run button
      runTestsBtn.disabled = false;
      
      // Update summary
      updateSummary();
      
      // Re-enable run button
      runTestsBtn.disabled = false;
      
      log('Test run completed', 'info');
    }
    
    // Update test summary
    function updateSummary() {
      summary.innerHTML = `
        <h3>Test Summary</h3>
        <p>Total Tests: ${testResults.total}</p>
        <p>Passed: ${testResults.passed}</p>
        <p>Failed: ${testResults.failed}</p>
        <p>Success Rate: ${Math.round((testResults.passed / testResults.total) * 100)}%</p>
        ${testResults.failed > 0 ? '<button id="copy-all-results">Copy All Results</button>' : ''}
      `;
      
      // Add event listener to the copy all results button if it exists
      const copyAllButton = document.getElementById('copy-all-results');
      if (copyAllButton) {
        copyAllButton.addEventListener('click', copyAllTestResults);
      }
    }
    
    // Copy all test results to clipboard
    function copyAllTestResults() {
      // Collect all test results
      const allResults = [];
      
      // Add test run summary
      allResults.push(`Test Run Summary (${new Date().toLocaleString()})`);
      allResults.push(`Total Tests: ${testResults.total}`);
      allResults.push(`Passed: ${testResults.passed}`);
      allResults.push(`Failed: ${testResults.failed}`);
      allResults.push(`Success Rate: ${Math.round((testResults.passed / testResults.total) * 100)}%`);
      allResults.push('\n--- Failed Tests ---');
      
      // Add details for each failed test
      tests.forEach(test => {
        const testItem = document.getElementById(`test-${test.id}`);
        if (testItem.classList.contains('failed')) {
          const detailsContainer = document.getElementById(`details-${test.id}`);
          const messageElement = detailsContainer.querySelector('p');
          const message = messageElement ? messageElement.textContent.replace('Message:', '').trim() : 'No message';
          
          allResults.push(`\n${test.name}:`);
          allResults.push(`- Error: ${message}`);
        }
      });
      
      // Add log entries
      allResults.push('\n--- Log Entries ---');
      const logEntries = document.querySelectorAll('.log-entry.error');
      logEntries.forEach(entry => {
        allResults.push(entry.textContent);
      });
      
      // Format as text
      const resultsText = allResults.join('\n');
      
      // Copy to clipboard
      navigator.clipboard.writeText(resultsText)
        .then(() => {
          // Show success feedback
          const copyAllButton = document.getElementById('copy-all-results');
          if (copyAllButton) {
            copyAllButton.textContent = 'Copied!';
            copyAllButton.classList.add('copy-success');
            
            // Reset button after 2 seconds
            setTimeout(() => {
              copyAllButton.textContent = 'Copy All Results';
              copyAllButton.classList.remove('copy-success');
            }, 2000);
          }
          
          log('All test results copied to clipboard', 'info');
        })
        .catch(err => {
          log(`Failed to copy test results: ${err}`, 'error');
        });
    }
    
    // Database Schema Functions
    let schemaData = null;
    
    // Load database schema
    async function loadDatabaseSchema() {
      const schemaLoading = document.getElementById('schema-loading');
      const schemaError = document.getElementById('schema-error');
      const schemaContent = document.getElementById('schema-content');
      const schemaErrorDetails = document.getElementById('schema-error-details');
      
      // Show loading
      schemaLoading.style.display = 'block';
      schemaError.style.display = 'none';
      schemaContent.innerHTML = '';
      
      try {
        const response = await fetch('/db-schema');
        const data = await response.json();
        
        if (data.success) {
          schemaData = data;
          renderSchemaData(data);
          log('Database schema loaded successfully', 'success');
        } else {
          schemaError.style.display = 'block';
          schemaErrorDetails.innerHTML = `
            <p><strong>Error:</strong> ${data.message}</p>
            <pre>${data.error || 'No additional error details'}</pre>
          `;
          log(`Failed to load database schema: ${data.message}`, 'error');
        }
      } catch (error) {
        schemaError.style.display = 'block';
        schemaErrorDetails.innerHTML = `
          <p><strong>Error:</strong> ${error.message}</p>
          <pre>${error.stack || 'No stack trace available'}</pre>
        `;
        log(`Error loading database schema: ${error.message}`, 'error');
      } finally {
        schemaLoading.style.display = 'none';
      }
    }
    
    // Render schema data
    function renderSchemaData(data) {
      const schemaContent = document.getElementById('schema-content');
      schemaContent.innerHTML = '';
      
      if (!data.tables || data.tables.length === 0) {
        schemaContent.innerHTML = '<p>No tables found in the database.</p>';
        return;
      }
      
      // Sort tables alphabetically
      const sortedTables = [...data.tables].sort((a, b) => a.name.localeCompare(b.name));
      
      // Create HTML for each table
      sortedTables.forEach(table => {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'schema-table';
        tableDiv.dataset.tableName = table.name;
        
        const tableHeader = document.createElement('h3');
        tableHeader.innerHTML = `
          <span>${table.name}</span>
          <button class="table-toggle" data-table="${table.name}">Hide</button>
        `;
        tableDiv.appendChild(tableHeader);
        
        const tableContent = document.createElement('div');
        tableContent.className = 'table-content';
        tableContent.dataset.table = table.name;
        
        if (table.columns && table.columns.length > 0) {
          const tableElement = document.createElement('table');
          tableElement.innerHTML = `
            <thead>
              <tr>
                <th>Column Name</th>
                <th>Data Type</th>
                <th>Nullable</th>
                <th>Default</th>
              </tr>
            </thead>
            <tbody>
              ${table.columns.map(column => `
                <tr>
                  <td>${column.column_name}</td>
                  <td>${column.data_type}</td>
                  <td>${column.is_nullable}</td>
                  <td>${column.column_default || 'NULL'}</td>
                </tr>
              `).join('')}
            </tbody>
          `;
          tableContent.appendChild(tableElement);
        } else {
          tableContent.innerHTML = '<p>No columns found for this table.</p>';
        }
        
        tableDiv.appendChild(tableContent);
        schemaContent.appendChild(tableDiv);
      });
      
      // Add event listeners to toggle buttons
      document.querySelectorAll('.table-toggle').forEach(button => {
        button.addEventListener('click', function() {
          const tableName = this.dataset.table;
          const tableContent = document.querySelector(`.table-content[data-table="${tableName}"]`);
          
          if (tableContent.style.display === 'none') {
            tableContent.style.display = 'block';
            this.textContent = 'Hide';
          } else {
            tableContent.style.display = 'none';
            this.textContent = 'Show';
          }
        });
      });
    }
    
    // Filter schema tables and columns
    function filterSchema(searchTerm) {
      if (!schemaData || !schemaData.tables) return;
      
      const term = searchTerm.toLowerCase();
      const schemaTables = document.querySelectorAll('.schema-table');
      
      schemaTables.forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName.toLowerCase();
        const tableRows = tableDiv.querySelectorAll('tbody tr');
        
        let tableVisible = tableName.includes(term);
        let visibleRows = 0;
        
        // Check columns
        tableRows.forEach(row => {
          const columnName = row.cells[0].textContent.toLowerCase();
          const columnType = row.cells[1].textContent.toLowerCase();
          
          if (columnName.includes(term) || columnType.includes(term)) {
            row.style.display = '';
            visibleRows++;
            tableVisible = true;
          } else {
            row.style.display = 'none';
          }
        });
        
        // Show/hide the table
        tableDiv.style.display = tableVisible ? '' : 'none';
      });
    }
    
    // Tab switching functionality
    function switchTab(tabId) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Deactivate all tab buttons
      document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
      });
      
      // Show the selected tab content
      document.getElementById(tabId).classList.add('active');
      
      // Activate the selected tab button
      document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
      
      // Load schema data if switching to schema tab
      if (tabId === 'schema-tab' && !schemaData) {
        loadDatabaseSchema();
      }
    }
    
    // Event listeners
    connectBtn.addEventListener('click', connectToServers);
    runTestsBtn.addEventListener('click', runAllTests);
    clearLogBtn.addEventListener('click', clearLog);
    
    // Schema tab event listeners
    document.getElementById('load-schema-btn').addEventListener('click', loadDatabaseSchema);
    document.getElementById('refresh-schema-btn').addEventListener('click', loadDatabaseSchema);
    
    // Search functionality
    document.getElementById('schema-search').addEventListener('input', function() {
      filterSchema(this.value);
    });
    
    // Tab switching event listeners
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', function() {
        switchTab(this.dataset.tab);
      });
    });
    
    // Initialize
    initializeTestList();
    log('API Test Runner initialized');
    log('Click "Connect to Servers" to begin');
  </script>
</body>
</html>
